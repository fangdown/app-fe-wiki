import{_ as e}from"./chunks/时间复杂度.BHqu7MWC.js";import{_ as o,c as a,o as c,a1 as l}from"./chunks/framework.BwTyoF0R.js";const m=JSON.parse('{"title":"旋转数组","description":"","frontmatter":{},"headers":[],"relativePath":"面试刷题-wiki/06-数据结构和算法/01-旋转数组.md","filePath":"面试刷题-wiki/06-数据结构和算法/01-旋转数组.md"}'),d={name:"面试刷题-wiki/06-数据结构和算法/01-旋转数组.md"},i=l('<h1 id="旋转数组" tabindex="-1">旋转数组 <a class="header-anchor" href="#旋转数组" aria-label="Permalink to &quot;旋转数组&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>定义一个函数，实现数组的旋转。如输入 <code>[1, 2, 3, 4, 5, 6, 7]</code> 和 <code>key = 3</code>， 输出 <code>[5, 6, 7, 1, 2, 3, 4]</code><br> 考虑时间复杂度和性能</p><h2 id="实现思路" tabindex="-1">实现思路 <a class="header-anchor" href="#实现思路" aria-label="Permalink to &quot;实现思路&quot;">​</a></h2><p>思路1</p><ul><li>将 <code>k</code> 后面的元素，挨个 <code>pop</code> 然后 <code>unshift</code> 到数组前面</li></ul><p>思路2</p><ul><li>将 <code>k</code> 后面的所有元素拿出来作为 <code>part1</code></li><li>将 <code>k</code> 前面的所有元素拿出来作为 <code>part2</code></li><li>返回 <code>part1.concat(part2)</code></li></ul><h2 id="写代码" tabindex="-1">写代码 <a class="header-anchor" href="#写代码" aria-label="Permalink to &quot;写代码&quot;">​</a></h2><ul><li>源码和性能测试 <code>array-rotate.js</code></li><li>单元测试 <code>array-rotate.test.js</code></li></ul><p>经过性能测试，知道“思路2”性能更优。看来，思路简单并不一定性能最优。</p><p>【注意】我看到网上有很多人为“思路1”的写法点赞，要保持独立思考，不要从众！</p><h2 id="时间复杂度" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h2><p>复杂度用 <code>O</code> 表示，说的是<strong>数量级</strong>，而不是具体的数字，如</p><ul><li><code>O(2)</code> <code>O(3)</code> <code>O(100)</code> 其实都是 <code>O(1)</code></li><li><code>O(n)</code> <code>O(2 * n)</code> 其实都是 <code>O(n)</code></li></ul><p>常见的时间复杂度</p><ul><li><code>O(1)</code> 无循环</li><li><code>O(n)</code> 单次循环</li><li><code>O(logn)</code> 二分法</li><li><code>O(n*logn)</code> 单次循环 &amp; 二分法</li><li><code>O(n^2)</code> 嵌套循环</li></ul><p><img src="'+e+'" alt=""></p><p>【注意】如果你用到了 API （如数组 <code>unshift</code>）要结合数据结构去分析复杂度。<strong>要看到代码的本质</strong>。</p><h2 id="空间复杂度" tabindex="-1">空间复杂度 <a class="header-anchor" href="#空间复杂度" aria-label="Permalink to &quot;空间复杂度&quot;">​</a></h2><p>算法需要额外定义多少变量？</p><ul><li><code>O(1)</code> 定义了为数不多的变量，和 <code>n</code> 无关</li><li><code>O(n)</code> 需要定义和 <code>n</code> 级别的变量，如额外复制一个同样的数组</li><li>其他不常见</li></ul><p>前端算法通常不太考虑空间复杂度，或者它比时间复杂度要次要的多。<br> 因为前端环境，通常内存都是足够的，或者内存不够通常也是其他因素（如媒体文件）。</p><h2 id="性能对比" tabindex="-1">性能对比 <a class="header-anchor" href="#性能对比" aria-label="Permalink to &quot;性能对比&quot;">​</a></h2><p>时间复杂度</p><ul><li>思路1 - 看代码时间复杂度是 <code>O(n)</code>，<strong>但数组是有序结构 <code>unshift</code> 本身就是 <code>O(n)</code> 复杂度</strong>，所以实际复杂度是 <code>O(n^2)</code></li><li>思路2 - <code>O(1)</code>。<code>slice</code> 和 <code>concat</code> 不会修改原数组，而数组是有序结构，复杂度是 <code>O(1)</code> 。</li></ul><p>空间复杂度</p><ul><li>思路1 - <code>O(1)</code></li><li>思路2 - <code>O(n)</code></li></ul><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><p>整体分析，选择“思路2”</p><h2 id="划重点" tabindex="-1">划重点 <a class="header-anchor" href="#划重点" aria-label="Permalink to &quot;划重点&quot;">​</a></h2><ul><li>考虑参数非法情况，代码鲁棒性</li><li>算法复杂度 <ul><li>要看到全部的时间复杂度（包括 API）</li><li>重时间，轻空间</li></ul></li><li>数组是有序结构，<code>shift</code> <code>unshift</code> 等要慎用</li><li>单元测试</li></ul><h2 id="扩展-不要过度优化" tabindex="-1">扩展 - 不要过度优化 <a class="header-anchor" href="#扩展-不要过度优化" aria-label="Permalink to &quot;扩展 - 不要过度优化&quot;">​</a></h2><p>其实还有一种思路，时间复杂度 <code>O(n)</code> ，空间复杂度 <code>O(1)</code> ，思路：</p><ul><li>k 前面的元素移动到 <code>i + (length - k)</code> 的位置</li><li>k 后面的元素移动到 <code>i - k</code> 的位置</li></ul><p>但不推荐这样的做法</p><ul><li>前端重时间、轻空间，优先考虑时间复杂度，而非空间复杂度</li><li>代码是否易读，是否易沟通 —— 这个比性能更重要！人力成本永远是最贵的！！</li></ul>',37),t=[i];function r(n,h,s,u,p,_){return c(),a("div",null,t)}const k=o(d,[["render",r]]);export{m as __pageData,k as default};
