import{_ as a,c as e,o as i,a1 as l}from"./chunks/framework.BwTyoF0R.js";const o="/assets/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.2jPRyLbP.png",b=JSON.parse('{"title":"斐波那契数列","description":"","frontmatter":{},"headers":[],"relativePath":"面试刷题-wiki/06-数据结构和算法/09-斐波那契数列.md","filePath":"面试刷题-wiki/06-数据结构和算法/09-斐波那契数列.md"}'),t={name:"面试刷题-wiki/06-数据结构和算法/09-斐波那契数列.md"},r=l('<h1 id="斐波那契数列" tabindex="-1">斐波那契数列 <a class="header-anchor" href="#斐波那契数列" aria-label="Permalink to &quot;斐波那契数列&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>用 Javascript 计算第 n 个斐波那契数列的值，注意时间复杂度。</p><h2 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h2><p>斐波那契数列很好理解</p><ul><li><code>f(0) = 0</code></li><li><code>f(1) = 1</code></li><li><code>f(n) = f(n - 1) + f(n - 2)</code> 前两个值的和</li></ul><h2 id="递归计算" tabindex="-1">递归计算 <a class="header-anchor" href="#递归计算" aria-label="Permalink to &quot;递归计算&quot;">​</a></h2><p>但这种方式会导致很多重复计算。<br> 时间复杂度是 <code>O(2^n)</code> ，爆炸式增长，不可用。（可以试试 <code>n: 100</code> ，程序会卡死）</p><p><img src="'+o+'" alt=""></p><h2 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h2><p>不用递归，用循环，记录中间结果。时间复杂度降低到 <code>O(n)</code></p><h2 id="动态规划" tabindex="-1">动态规划 <a class="header-anchor" href="#动态规划" aria-label="Permalink to &quot;动态规划&quot;">​</a></h2><p>即，把一个大问题，拆解为不同的小问题，递归向下。</p><p>【注意】一般使用动态规划的思路（递归）分析问题，再转换为循环来解决问题。</p><h2 id="三大算法思维" tabindex="-1">三大算法思维 <a class="header-anchor" href="#三大算法思维" aria-label="Permalink to &quot;三大算法思维&quot;">​</a></h2><ul><li>贪心（递归）</li><li>二分</li><li>动态规划</li></ul><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><p>使用循环的方式，参考 fibonacci.ts</p><h2 id="划重点" tabindex="-1">划重点 <a class="header-anchor" href="#划重点" aria-label="Permalink to &quot;划重点&quot;">​</a></h2><ul><li>动态规划的思路</li><li>识别出时间复杂度</li></ul><h2 id="扩展" tabindex="-1">扩展 <a class="header-anchor" href="#扩展" aria-label="Permalink to &quot;扩展&quot;">​</a></h2><p>青蛙跳台阶：一只青蛙，一次可以跳 1 个台阶，也可以跳 2 个台阶，问该青蛙跳上 n 级台阶，总共有多少种方式？</p><p>分析</p><ul><li><code>f(1) = 1</code> 跳 1 级台阶，只有一种方式</li><li><code>f(2) = 2</code> 跳 2 级台阶，有两种方式</li><li><code>f(n) = f(n - 1) + fn(n - 2)</code> 跳 n 级，可拆分为两个问题 <ul><li>第一次跳，要么 1 级，要么 2 级，只有这两种</li><li>第一次跳 1 级，剩下有 <code>f(n - 1)</code> 种方式</li><li>第一次跳 2 级，剩下有 <code>f(n - 2)</code> 种方式</li></ul></li></ul><p>看公式，和斐波那契数列一样。</p>',25),c=[r];function n(d,h,s,_,p,u){return i(),e("div",null,c)}const m=a(t,[["render",n]]);export{b as __pageData,m as default};
