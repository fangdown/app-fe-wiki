import{_ as a,c as e,o,a1 as t}from"./chunks/framework.BwTyoF0R.js";const b=JSON.parse('{"title":"连续最多的字符","description":"","frontmatter":{},"headers":[],"relativePath":"面试刷题-wiki/06-数据结构和算法/11-连续最多的字符.md","filePath":"面试刷题-wiki/06-数据结构和算法/11-连续最多的字符.md"}'),r={name:"面试刷题-wiki/06-数据结构和算法/11-连续最多的字符.md"},i=t('<h1 id="连续最多的字符" tabindex="-1">连续最多的字符 <a class="header-anchor" href="#连续最多的字符" aria-label="Permalink to &quot;连续最多的字符&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>给一个字符串，找出连续最多的字符，以及次数。<br> 例如字符串 <code>&#39;aabbcccddeeee11223&#39;</code> 连续最多的是 <code>e</code> ，4 次。</p><h2 id="传统方式" tabindex="-1">传统方式 <a class="header-anchor" href="#传统方式" aria-label="Permalink to &quot;传统方式&quot;">​</a></h2><p>嵌套循环，找出每个字符的连续次数，并记录比较。</p><p>时间复杂度看似是 <code>O(n^2)</code>，因为是嵌套循环。 <strong>但实际上它的时间复杂度是 <code>O(n)</code>，因为循环中有跳转</strong>。</p><h2 id="双指针" tabindex="-1">双指针 <a class="header-anchor" href="#双指针" aria-label="Permalink to &quot;双指针&quot;">​</a></h2><p>画图解释，参考视频讲解。</p><p>只有一次循环，时间复杂度是 <code>O(n)</code></p><p>性能测试，发现两者时间消耗一样，<strong>循环次数也一样</strong>。</p><h2 id="其他方式" tabindex="-1">其他方式 <a class="header-anchor" href="#其他方式" aria-label="Permalink to &quot;其他方式&quot;">​</a></h2><p>这个题目网上还有其他的答案</p><ul><li>正则表达式 —— 正则表达式的效率非常低，可进行性能测试（代码 <code>x-reg.ts</code> ）</li><li>使用数组累计各个字符串的长度，然后求出最大值 —— 增加空间复杂度，面试官不会喜欢</li></ul><p>【注意】算法尽量用基础代码实现，尽量不要用现成的 API 或语法糖 —— 方便，但你不好直观判断时间复杂度</p><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><p>上述两种方式（嵌套循环和双指针）都可以，参考 continuous-char.ts</p><h2 id="划重点" tabindex="-1">划重点 <a class="header-anchor" href="#划重点" aria-label="Permalink to &quot;划重点&quot;">​</a></h2><ul><li>注意实际的时间复杂度，不要被代码所迷惑</li><li>双指针的思路（常用于解决嵌套循环）</li></ul>',18),c=[i];function l(d,n,h,s,_,p){return o(),e("div",null,c)}const m=a(r,[["render",l]]);export{b as __pageData,m as default};
