import{_ as s,c as i,o as a,a1 as e}from"./chunks/framework.BwTyoF0R.js";const u=JSON.parse('{"title":"Vue 优化","description":"","frontmatter":{},"headers":[],"relativePath":"面试刷题-wiki/05-实际工作经验/05-vue优化.md","filePath":"面试刷题-wiki/05-实际工作经验/05-vue优化.md"}'),l={name:"面试刷题-wiki/05-实际工作经验/05-vue优化.md"},n=e(`<h1 id="vue-优化" tabindex="-1">Vue 优化 <a class="header-anchor" href="#vue-优化" aria-label="Permalink to &quot;Vue 优化&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>你在实际工作中，做过哪些 Vue 优化？</p><h2 id="前端通用的优化策略" tabindex="-1">前端通用的优化策略 <a class="header-anchor" href="#前端通用的优化策略" aria-label="Permalink to &quot;前端通用的优化策略&quot;">​</a></h2><p>压缩资源，拆包，使用 CDN ，http 缓存等。本节只讨论首屏，这些先不讲。</p><h2 id="v-if-和-v-show" tabindex="-1">v-if 和 v-show <a class="header-anchor" href="#v-if-和-v-show" aria-label="Permalink to &quot;v-if 和 v-show&quot;">​</a></h2><p>区别</p><ul><li><code>v-if</code> 组件销毁/重建</li><li><code>v-show</code> 组件隐藏（切换 CSS <code>display</code>）</li></ul><p>场景</p><ul><li>一般情况下使用 <code>v-if</code> 即可，普通组件的销毁、渲染不会造成性能问题</li><li>如果组件创建时需要大量计算，或者大量渲染（如复杂的编辑器、表单、地图等），可以考虑 <code>v-show</code></li></ul><h2 id="v-for-使用-key" tabindex="-1">v-for 使用 key <a class="header-anchor" href="#v-for-使用-key" aria-label="Permalink to &quot;v-for 使用 key&quot;">​</a></h2><p><code>key</code> 可以优化内部的 diff 算法。注意，遍历数组时 <code>key</code> 不要使用 <code>index</code> 。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    &lt;!-- 而且，key 不要用 index --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;(id, name) in list&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{name}}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="computed-缓存" tabindex="-1">computed 缓存 <a class="header-anchor" href="#computed-缓存" aria-label="Permalink to &quot;computed 缓存&quot;">​</a></h2><p><code>computed</code> 可以缓存计算结果，<code>data</code> 不变则缓存不失效。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            msgList: [ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 消息列表</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    computed: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 未读消息的数量</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        unreadCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.msgList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m.read </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="keep-alive" tabindex="-1">keep-alive <a class="header-anchor" href="#keep-alive" aria-label="Permalink to &quot;keep-alive&quot;">​</a></h2><p><code>&lt;keep-alive&gt;</code> 可以缓存子组件，只创建一次。通过 <code>activated</code> 和 <code>deactivated</code> 生命周期监听是否显示状态。<br> 代码参考 components/KeepAlive/index.vue</p><p>场景</p><ul><li>局部频繁切换的组件，如 tabs</li><li>不可乱用 <code>&lt;keep-alive&gt;</code> ，缓存太多会占用大量内存，而且出问题不好 debug</li></ul><h2 id="异步组件" tabindex="-1">异步组件 <a class="header-anchor" href="#异步组件" aria-label="Permalink to &quot;异步组件&quot;">​</a></h2><p>对于体积大的组件（如编辑器、表单、地图等）可以使用异步组件</p><ul><li>拆包，需要时异步加载，不需要时不加载</li><li>减少 main 包的体积，页面首次加载更快</li></ul><p>vue3 使用 <code>defineAsyncComponent</code> 加载异步组件，代码参考 components/AsyncComponent/index.vue</p><h2 id="路由懒加载" tabindex="-1">路由懒加载 <a class="header-anchor" href="#路由懒加载" aria-label="Permalink to &quot;路由懒加载&quot;">​</a></h2><p>对于一些补偿访问的路由，或者组件提交比较大的路由，可以使用路由懒加载。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> routes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Home&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    component: Home</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/about&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;About&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 路由懒加载</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* webpackChunkName: &quot;about&quot; */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;../views/About.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><h2 id="ssr" tabindex="-1">SSR <a class="header-anchor" href="#ssr" aria-label="Permalink to &quot;SSR&quot;">​</a></h2><p>SSR 让网页访问速度更快，对 SEO 友好。</p><p>但 SSR 使用和调试成本高，不可乱用。例如，一个低代码项目（在线制作 H5 网页），toB 部分不可用 SSR ， toC 部分适合用 SSR 。</p><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><ul><li>v-if 和 v-show</li><li>v-for 使用 key</li><li>computed 缓存</li><li>keep-alive</li><li>异步组件</li><li>路由懒加载</li><li>SSR</li></ul><h2 id="扩展" tabindex="-1">扩展 <a class="header-anchor" href="#扩展" aria-label="Permalink to &quot;扩展&quot;">​</a></h2><p>网上看到过一些“较真”的性能优化，对比普通组件和函数组件，JS 执行多消耗了几 ms 。</p><ul><li>如果这些是为了探索、学习前端技术，非常推荐</li><li>但在实际项目中要慎用，不要为了优化而优化。肉眼不可见的 ms 级的优化，对项目没有任何实际价值</li></ul><h2 id="连环问-vue-遇到过哪些坑" tabindex="-1">连环问：Vue 遇到过哪些坑？？？ <a class="header-anchor" href="#连环问-vue-遇到过哪些坑" aria-label="Permalink to &quot;连环问：Vue 遇到过哪些坑？？？&quot;">​</a></h2><p>全局事件、自定义事件要在组件销毁时解除绑定</p><ul><li>内存泄漏风险</li><li>全局事件（如 <code>window.resize</code>）不解除，则会继续监听，而且组件再次创建时会重复绑定</li></ul><p>Vue2.x 中，无法监听 data 属性的新增和删除，以及数组的部分修改 —— Vue3 不会有这个问题</p><ul><li>新增 data 属性，需要用 <code>Vue.set</code></li><li>删除 data 属性，需要用 <code>Vue.delete</code></li><li>修改数组某一元素，不能 <code>arr[index] = value</code> ，要使用 <code>arr.splice</code> API 方式</li></ul><p>路由切换时，页面会 scroll 到顶部。例如，在一个新闻列表页下滑到一定位置，点击进入详情页，在返回列表页，此时会 scroll 到顶部，并重新渲染列表页。所有的 SPA 都会有这个问题，并不仅仅是 Vue 。</p><ul><li>在列表页缓存数据和 <code>scrollTop</code></li><li>返回列表页时（用 Vue-router <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noreferrer">导航守卫</a>，判断 <code>from</code>），使用缓存数据渲染页面，然后 <code>scrollTo(scrollTop)</code></li></ul>`,42),t=[n];function h(p,k,d,r,o,E){return a(),i("div",null,t)}const g=s(l,[["render",h]]);export{u as __pageData,g as default};
