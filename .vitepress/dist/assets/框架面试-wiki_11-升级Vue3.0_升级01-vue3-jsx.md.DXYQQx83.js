import{_ as o,c as i,j as e,a as t,t as s,a1 as a,o as d}from"./chunks/framework.BwTyoF0R.js";const J=JSON.parse('{"title":"vue3 JSX","description":"","frontmatter":{},"headers":[],"relativePath":"框架面试-wiki/11-升级Vue3.0/升级01-vue3-jsx.md","filePath":"框架面试-wiki/11-升级Vue3.0/升级01-vue3-jsx.md"}'),c={name:"框架面试-wiki/11-升级Vue3.0/升级01-vue3-jsx.md"},u=a('<h1 id="vue3-jsx" tabindex="-1">vue3 JSX <a class="header-anchor" href="#vue3-jsx" aria-label="Permalink to &quot;vue3 JSX&quot;">​</a></h1><p>【注意】如果对 JSX 语法不熟悉，可以先去学习 React 部分。</p><h2 id="开始" tabindex="-1">开始 <a class="header-anchor" href="#开始" aria-label="Permalink to &quot;开始&quot;">​</a></h2><ul><li>vue3 中 JSX 的基本使用</li><li>JSX 和 template 的区别</li><li>JSX 和 slot</li><li>JSX 和 作用域 slot</li></ul><h2 id="vue3-中-jsx-的基本使用" tabindex="-1">vue3 中 JSX 的基本使用 <a class="header-anchor" href="#vue3-中-jsx-的基本使用" aria-label="Permalink to &quot;vue3 中 JSX 的基本使用&quot;">​</a></h2><ul><li>基本使用</li><li>使用 <code>.jsx</code> 格式的文件，使用 <code>defineComponent</code><ul><li>可以传入一个配置</li><li>也可以传入一个 <code>setup</code> 函数</li></ul></li><li>引入子组件，传递属性</li></ul><h2 id="jsx-和-template-的区别" tabindex="-1">JSX 和 template 的区别 <a class="header-anchor" href="#jsx-和-template-的区别" aria-label="Permalink to &quot;JSX 和 template 的区别&quot;">​</a></h2><p>语法的区别：</p><ul><li>JSX 就是 js 代码，它可以使用任何 js 的能力。</li><li>template 是模板语法，目前只能插入一些简单的 js 表达式。逻辑则需要指令，如 <code>v-for</code> <code>v-if</code> 等。</li><li>JSX 已经成为了 ES 规范语法，babel 支持。而 template 只是 vue 自家的语法规范。</li></ul><p>但本质是相同的：他们都会被编译成 render 函数，用于渲染 vnode<br> 在 vue React 原理都讲过，这里不再重复</p><h3 id="插值" tabindex="-1">插值 <a class="header-anchor" href="#插值" aria-label="Permalink to &quot;插值&quot;">​</a></h3>',11),r=e("li",null,[t("JSX 用 "),e("code",null,"{xxx}")],-1),n=a('<h3 id="自定义组件" tabindex="-1">自定义组件 <a class="header-anchor" href="#自定义组件" aria-label="Permalink to &quot;自定义组件&quot;">​</a></h3><ul><li>template 可用 <code>&lt;custom-component&gt;&lt;/custom-component&gt;</code> 或者 <code>&lt;CustomComponent&gt;&lt;/CustomComponent&gt;</code></li><li>JSX 必须使用 <code>&lt;CustomComponent&gt;&lt;/CustomComponent&gt;</code></li></ul><h3 id="传递属性和事件" tabindex="-1">传递属性和事件 <a class="header-anchor" href="#传递属性和事件" aria-label="Permalink to &quot;传递属性和事件&quot;">​</a></h3><ul><li>template 中使用 <code>a=&quot;xx&quot;</code> 或 <code>:a=&quot;xx&quot;</code> ，<code>@xx=&quot;xx&quot;</code></li><li>JSX 中全部使用 <code>a={xx}</code></li></ul><h3 id="条件-循环" tabindex="-1">条件，循环 <a class="header-anchor" href="#条件-循环" aria-label="Permalink to &quot;条件，循环&quot;">​</a></h3><ul><li>template 使用指令 <code>v-for</code> <code>v-if</code> 等</li><li>JSX 中使用 js 表达式</li></ul><h2 id="jsx-和-slot" tabindex="-1">JSX 和 slot <a class="header-anchor" href="#jsx-和-slot" aria-label="Permalink to &quot;JSX 和 slot&quot;">​</a></h2><p>因为 template 只能内嵌简单的 js 表达式，无法内嵌组件，所以 vue 只能自造一个 <code>&lt;slot&gt;</code> 语法。</p><p>vue3 setup 中可以使用 <code>context.slots.default()</code> 获取子组件</p><p>使用 tabs 组件演示 JSX 如何操作 slot</p><h2 id="jsx-和作用域-slot" tabindex="-1">JSX 和作用域 slot <a class="header-anchor" href="#jsx-和作用域-slot" aria-label="Permalink to &quot;JSX 和作用域 slot&quot;">​</a></h2><p>回顾作用域 slot ，就是：父组件想要获取子组件的信息，并渲染到 slot 中</p><p>作用域 slot 很难理解，一直是 vue 初学者的噩梦。但用 JSX 将会变的很好理解，因为它就是 js 代码逻辑。</p><p>代码的方式，在 react 中叫做“renderProps”</p>',14);function h(l,p,x,m,_,S){return d(),i("div",null,[u,e("ul",null,[e("li",null,[t("template 用 "),e("code",null,s(l.xxx),1)]),r]),n])}const v=o(c,[["render",h]]);export{J as __pageData,v as default};
