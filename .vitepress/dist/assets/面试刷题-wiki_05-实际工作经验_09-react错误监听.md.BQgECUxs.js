import{_ as s,c as i,o as a,a1 as n}from"./chunks/framework.BwTyoF0R.js";const g=JSON.parse('{"title":"React 错误监听","description":"","frontmatter":{},"headers":[],"relativePath":"面试刷题-wiki/05-实际工作经验/09-react错误监听.md","filePath":"面试刷题-wiki/05-实际工作经验/09-react错误监听.md"}'),t={name:"面试刷题-wiki/05-实际工作经验/09-react错误监听.md"},e=n(`<h1 id="react-错误监听" tabindex="-1">React 错误监听 <a class="header-anchor" href="#react-错误监听" aria-label="Permalink to &quot;React 错误监听&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>如何统一监听 React 组件报错？</p><h2 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h2><p>真实项目需要<strong>闭环</strong>，即考虑各个方面，除了基本的功能外，还要考虑性能优化、报错、统计等。 而个人项目、课程项目一般以实现功能为主，不会考虑这么全面。所以，没有实际工作经验的同学，不会了解如此全面。</p><h2 id="errorboundary" tabindex="-1">ErrorBoundary <a class="header-anchor" href="#errorboundary" aria-label="Permalink to &quot;ErrorBoundary&quot;">​</a></h2><p>React 16+ 引入。可以监听所有<strong>下级</strong>组件报错，同时降级展示 UI 。<br> 代码参考 ErrorBoundary.js 和 components/ErrorDemo</p><p>建议应用到最顶层，监听全局错误</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// index.js 入口文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ReactDOM.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">React.StrictMode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ErrorBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ErrorBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">React.StrictMode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;root&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>函数组件中也可以使用</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ErrorBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {props.children}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ErrorBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="dev-和-build" tabindex="-1">dev 和 build <a class="header-anchor" href="#dev-和-build" aria-label="Permalink to &quot;dev 和 build&quot;">​</a></h2><p>dev 环境下无法看到 ErrorBoundary 的报错 UI 效果。会显示的提示报错信息。<br><code>yarn build</code> 之后再运行，即可看到 UI 效果。</p><h2 id="事件报错" tabindex="-1">事件报错 <a class="header-anchor" href="#事件报错" aria-label="Permalink to &quot;事件报错&quot;">​</a></h2><p>React 不需要 ErrorBoundary 来捕获事件处理器中的错误。与 <code>render</code> 方法和生命周期方法不同，事件处理器不会在渲染期间触发。</p><p>如果你需要在事件处理器内部捕获错误，使用普通的 <code>try-catch</code> 语句。也可以使用全局的 <code>window.onerror</code> 来监听。</p><h2 id="异步错误" tabindex="-1">异步错误 <a class="header-anchor" href="#异步错误" aria-label="Permalink to &quot;异步错误&quot;">​</a></h2><p>ErrorBoundary 无法捕捉到异步报错，可使用 <code>window.onerror</code> 来监听。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onerror</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">line</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">column</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;window.onerror---------&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, msg, source, line, column, error)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注意，如果用 window.addEventListener(&#39;error&#39;, event =&gt; {}) 参数不一样！！！</span></span></code></pre></div><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><ul><li>ErrorBoundary 监听渲染时报错</li><li><code>try-catch</code> 和 <code>window.onerror</code> 捕获其他错误</li></ul><h2 id="扩展" tabindex="-1">扩展 <a class="header-anchor" href="#扩展" aria-label="Permalink to &quot;扩展&quot;">​</a></h2><p>Promise 监听报错要使用 <code>window.onunhandledrejection</code> ，后面会有面试题讲解。</p><p>前端拿到错误监听之后，需要传递给服务端，进行错误收集和分析，然后修复 bug 。 后面会有一道面试题专门讲解。</p>`,24),h=[e];function l(r,p,k,d,o,E){return a(),i("div",null,h)}const y=s(t,[["render",l]]);export{g as __pageData,y as default};
