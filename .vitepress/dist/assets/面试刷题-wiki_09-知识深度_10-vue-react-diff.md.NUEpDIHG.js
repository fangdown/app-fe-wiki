import{_ as i,c as s,o as a,a1 as e}from"./chunks/framework.BwTyoF0R.js";const t="/assets/tree-diff.C4ogyqMo.png",l="/assets/tree-diff-1.CUEWFriC.png",n="/assets/react-diff.D_dlOTNV.png",d="/assets/vue2-diff.i_LgcNRw.png",h="/assets/vue3-diff.Brv2W_wM.png",p="/assets/key.CFKp53g2.png",b=JSON.parse('{"title":"Vue React diff","description":"","frontmatter":{},"headers":[],"relativePath":"面试刷题-wiki/09-知识深度/10-vue-react-diff.md","filePath":"面试刷题-wiki/09-知识深度/10-vue-react-diff.md"}'),o={name:"面试刷题-wiki/09-知识深度/10-vue-react-diff.md"},r=e('<h1 id="vue-react-diff" tabindex="-1">Vue React diff <a class="header-anchor" href="#vue-react-diff" aria-label="Permalink to &quot;Vue React diff&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>Vue React diff 算法有什么区别</p><h2 id="diff-算法" tabindex="-1">diff 算法 <a class="header-anchor" href="#diff-算法" aria-label="Permalink to &quot;diff 算法&quot;">​</a></h2><p>diff 算法是一个非常普遍常用的方法，例如提交 github pr 或者（gitlab mr）时，会对比当前提交代码的改动，这就是 diff 。</p><p>Vue React diff 不是对比文字，而是 vdom 树，即 tree diff 。<br> 传统的 tree diff 算法复杂度是 <code>O(n^3)</code> ，算法不可用。</p><p><img src="'+t+'" alt=""></p><h2 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h2><p>Vue React 都是用于网页开发，基于 DOM 结构，对 diff 算法都进行了优化（或者简化）</p><ul><li>只在同一层级比较，不夸层级 （DOM 结构的变化，很少有跨层级移动）</li><li><code>tag</code> 不同则直接删掉重建，不去对比内部细节（DOM 结构变化，很少有只改外层，不改内层）</li><li>同一个节点下的子节点，通过 <code>key</code> 区分</li></ul><p>最终把时间复杂度降低到 <code>O(n)</code> ，生产环境下可用。这一点 Vue React 都是相同的。</p><p><img src="'+l+'" alt=""></p><h2 id="react-diff-特点-仅向右移动" tabindex="-1">React diff 特点 - 仅向右移动 <a class="header-anchor" href="#react-diff-特点-仅向右移动" aria-label="Permalink to &quot;React diff 特点 - 仅向右移动&quot;">​</a></h2><p>比较子节点时，仅向右移动，不向左移动。</p><p><img src="'+n+'" alt=""></p><h2 id="vue2-diff-特点-双端比较" tabindex="-1">Vue2 diff 特点 - 双端比较 <a class="header-anchor" href="#vue2-diff-特点-双端比较" aria-label="Permalink to &quot;Vue2 diff 特点 - 双端比较&quot;">​</a></h2><p><img src="'+d+'" alt=""></p><p>定义四个指针，分别比较</p><ul><li>oldStartNode 和 newStartNode</li><li>oldStartNode 和 newEndNode</li><li>oldEndNode 和 newStartNode</li><li>oldEndNode 和 newEndNode</li></ul><p>然后指针继续向中间移动，知道指针汇合。</p><h2 id="vue3-diff-特点-最长递增子序列" tabindex="-1">Vue3 diff 特点 - 最长递增子序列 <a class="header-anchor" href="#vue3-diff-特点-最长递增子序列" aria-label="Permalink to &quot;Vue3 diff 特点 - 最长递增子序列&quot;">​</a></h2><p>例如数组 <code>[3，5，7，1，2，8]</code> 的最长递增子序列就是 <code>[3，5，7，8 ]</code> 。这是一个专门的算法。</p><p><img src="'+h+'" alt=""></p><p>算法步骤</p><ul><li>通过“前-前”比较找到开始的不变节点 <code>[A, B]</code></li><li>通过“后-后”比较找到末尾的不变节点 <code>[G]</code></li><li>剩余的有变化的节点 <code>[F, C, D, E, H]</code><ul><li>通过 <code>newIndexToOldIndexMap</code> 拿到 oldChildren 中对应的 index <code>[5, 2, 3, 4, -1]</code> （<code>-1</code> 表示之前没有，要新增）</li><li>计算<strong>最长递增子序列</strong>得到 <code>[2, 3, 4]</code> ，对应的就是 <code>[C, D, E]</code> ，即这些节点可以不变</li><li>剩余的节点，根据 index 进行新增、删除</li></ul></li></ul><p>该方法旨在尽量减少 DOM 的移动，达到最少的 DOM 操作。</p><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><ul><li>React diff 特点 - 仅向右移动</li><li>Vue2 diff 特点 - 双端比较</li><li>Vue3 diff 特点 - 最长递增子序列</li></ul><h2 id="划重点" tabindex="-1">划重点 <a class="header-anchor" href="#划重点" aria-label="Permalink to &quot;划重点&quot;">​</a></h2><p>以最小的成本了解原理，知道区别，应对面试。<br> 不要纠结于细节和源码，这会耗费你大量的时间成本 —— 除非你目的就是学习源码，这也不是本课程的重点。</p><h2 id="连环问-diff-算法中-key-为何如此重要" tabindex="-1">连环问：diff 算法中 key 为何如此重要 <a class="header-anchor" href="#连环问-diff-算法中-key-为何如此重要" aria-label="Permalink to &quot;连环问：diff 算法中 key 为何如此重要&quot;">​</a></h2><p>无论在 Vue 还是 React 中，<code>key</code> 的作用都非常大。以 React 为例，是否使用 <code>key</code> 对内部 DOM 变化影响非常大。</p><p><img src="'+p+`" alt=""></p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;(index, num) in nums&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {{num}}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> todoItems</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> todos.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">todo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{todo.id}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {todo.text}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,35),k=[r];function c(f,E,u,g,y,m){return a(),s("div",null,k)}const v=i(o,[["render",c]]);export{b as __pageData,v as default};
