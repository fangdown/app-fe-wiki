import{_ as o,c as e,o as i,a1 as a}from"./chunks/framework.BwTyoF0R.js";const t="/assets/cookie.BaeeEmEX.png",l="/assets/token.C1pPAifo.png",c="/assets/sso.Bx-Q72TW.png",q=JSON.parse('{"title":"cookie 和 token 区别","description":"","frontmatter":{},"headers":[],"relativePath":"面试刷题-wiki/08-知识广度/03-token和cookie区别.md","filePath":"面试刷题-wiki/08-知识广度/03-token和cookie区别.md"}'),s={name:"面试刷题-wiki/08-知识广度/03-token和cookie区别.md"},n=a('<h1 id="cookie-和-token-区别" tabindex="-1">cookie 和 token 区别 <a class="header-anchor" href="#cookie-和-token-区别" aria-label="Permalink to &quot;cookie 和 token 区别&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>cookie 和 token 有何区别</p><h2 id="cookie" tabindex="-1">cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;cookie&quot;">​</a></h2><p>http 请求是无状态的，即每次请求之后都会断开链接。<br> 所以，每次请求时，都可以携带一段信息发送到服务端，以表明客户端的用户身份。服务端也也可以通过 <code>set-cookie</code> 向客户端设置 cookie 内容。<br> 由于每次请求都携带 cookie ，所以 cookie 大小限制 4kb 以内。</p><p><img src="'+t+'" alt=""></p><h2 id="cookie-作为本地存储" tabindex="-1">cookie 作为本地存储 <a class="header-anchor" href="#cookie-作为本地存储" aria-label="Permalink to &quot;cookie 作为本地存储&quot;">​</a></h2><p>前些年大家还常用 cookie 作为本地存储，这并不完全合适。<br> 所以后来 html5 增加了 <code>localStorage</code> 和 <code>sessionStorage</code> 作为本地存储。</p><h2 id="cookie-跨域限制" tabindex="-1">cookie 跨域限制 <a class="header-anchor" href="#cookie-跨域限制" aria-label="Permalink to &quot;cookie 跨域限制&quot;">​</a></h2><p>浏览器存储 cookie 是按照域名区分的，在浏览器无法通过 JS <code>document.cookie</code> 获取到其他域名的 cookie 。</p><p>http 请求传递 cookie 默认有跨域限制。如果想要开启，需要客户端和服务器同时设置允许</p><ul><li>客户端：使用 fetch 和 XMLHttpRequest 或者 axios 需要配置 <code>withCredentials</code></li><li>服务端：需要配置 header <code>Access-Control-Allow-Credentials</code></li></ul><h2 id="浏览器禁用第三发-cookie" tabindex="-1">浏览器禁用第三发 cookie <a class="header-anchor" href="#浏览器禁用第三发-cookie" aria-label="Permalink to &quot;浏览器禁用第三发 cookie&quot;">​</a></h2><p>现代浏览器都开始禁用第三方 cookie （第三方 js 设置 cookie），打击第三方广告，保护用户个人隐私。</p><p>例如一个电商网站 A 引用了淘宝广告的 js</p><ul><li>你访问 A 时，淘宝 js 设置 cookie ，记录下商品信息</li><li>你再次访问淘宝时，淘宝即可获取这个 cookie 内容</li><li>再和你的个人信息（也在 cookie 里）一起发送到服务端，这样就知道了你看了哪个商品</li></ul><h2 id="cookie-和-session" tabindex="-1">cookie 和 session <a class="header-anchor" href="#cookie-和-session" aria-label="Permalink to &quot;cookie 和 session&quot;">​</a></h2><p>cookie 用途非常广泛，最常见的就是登录。</p><p>使用 cookie 做登录校验</p><ul><li>前端输入用户名密码，传给后端</li><li>后端验证成功，返回信息时 set-cookie</li><li>接下来所有接口访问，都自动带上 cookie （浏览器的默认行为， http 协议的规定）</li></ul><p>什么是 session ？</p><ul><li>cookie 只存储 userId ，不去暴露用户信息</li><li>用户信息存储在 session 中 —— session 就是服务端的一个 hash 表</li></ul><h2 id="token" tabindex="-1">token <a class="header-anchor" href="#token" aria-label="Permalink to &quot;token&quot;">​</a></h2><p>token 和 cookie 一样，也是一段用于客户端身份验证的字符串，随着 http 请求发送</p><ul><li>cookie 是 http 协议规范的，而 token 是自定义的，可以用任何方式传输（如 header body query-string 等）</li><li>token 默认不会在浏览器存储</li><li>token 没有跨域限制</li></ul><p>所以，token 很适合做跨域或者第三方的身份验证。</p><h2 id="token-和-jwt" tabindex="-1">token 和 JWT <a class="header-anchor" href="#token-和-jwt" aria-label="Permalink to &quot;token 和 JWT&quot;">​</a></h2><p>JWT === JSON Web Token</p><p>JWT 的过程</p><ul><li>前端输入用户名密码，传给后端</li><li>后端验证成功，返回一段 token 字符串 - 将用户信息加密之后得到的</li><li>前端获取 token 之后，存储下来</li><li>以后访问接口，都在 header 中带上这段 token</li></ul><p><img src="'+l+'" alt=""></p><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><ul><li>cookie：http 规范；有跨域限制；可存储在本地；可配合 session 实现登录</li><li>token：自定义标准；不在本地存储；无跨域限制；可用于 JWT 登录</li></ul><h2 id="连环问-session-和-jwt-比较-你更推荐哪个" tabindex="-1">连环问：session 和 JWT 比较，你更推荐哪个？ <a class="header-anchor" href="#连环问-session-和-jwt-比较-你更推荐哪个" aria-label="Permalink to &quot;连环问：session 和 JWT 比较，你更推荐哪个？&quot;">​</a></h2><p>Session 优点</p><ul><li>原理简单，易于学习</li><li>用户信息存储在服务端，可以快速封禁某个登录的用户 —— 有这方强需求的人，一定选择 Session</li></ul><p>Session 的缺点</p><ul><li>占用服务端内存，有硬件成本</li><li>多进程、多服务器时，不好同步 —— 一般使用第三方 redis 存储 ，成本高</li><li>跨域传递 cookie ，需要特殊配置</li></ul><p>JWT 的优点</p><ul><li>不占用服务器内存</li><li>多进程、多服务器，不受影响</li><li>不受跨域限制</li></ul><p>JWT 的缺点</p><ul><li>无法快速封禁登录的用户</li></ul><p>总结：如果没有“快速封禁登录用户”的需求，建议使用 JWT 方式。</p><h2 id="连环问-单点登录" tabindex="-1">连环问：单点登录 <a class="header-anchor" href="#连环问-单点登录" aria-label="Permalink to &quot;连环问：单点登录&quot;">​</a></h2><h3 id="基于-cookie" tabindex="-1">基于 cookie <a class="header-anchor" href="#基于-cookie" aria-label="Permalink to &quot;基于 cookie&quot;">​</a></h3><p>简单的，如果业务系统都在同一主域名下，比如 <code>wenku.baidu.com</code> <code>tieba.baidu.com</code> ，就好办了。 可以直接把 cookie domain 设置为主域名 <code>baidu.com</code> ，百度也就是这么干的。</p><h3 id="sso" tabindex="-1">SSO <a class="header-anchor" href="#sso" aria-label="Permalink to &quot;SSO&quot;">​</a></h3><p>复杂一点的，滴滴这么潮的公司，同时拥有 <code>didichuxing.com</code> <code>xiaojukeji.com</code> <code>didiglobal.com</code> 等域名，种 cookie 是完全绕不开的。需要使用 SSO 技术方案</p><p><img src="'+c+'" alt=""></p><h3 id="oauth2" tabindex="-1">OAuth2 <a class="header-anchor" href="#oauth2" aria-label="Permalink to &quot;OAuth2&quot;">​</a></h3><p>上述 SSO 是 oauth 的实际案例，其他常见的还有微信登录、github 登录等。即，当设计到第三方用户登录校验时，都会使用 OAuth2.0 标准。 流程参考 <a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noreferrer">RFC 6749</a></p>',51),r=[n];function k(h,d,p,u,b,m){return i(),e("div",null,r)}const f=o(s,[["render",k]]);export{q as __pageData,f as default};
