import{_ as i,c as e,o,a1 as a}from"./chunks/framework.BwTyoF0R.js";const t="/assets/%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87.BKKFtMPx.png",v=JSON.parse('{"title":"解答-1","description":"","frontmatter":{},"headers":[],"relativePath":"框架面试-wiki/11-升级Vue3.0/02-解答-1.md","filePath":"框架面试-wiki/11-升级Vue3.0/02-解答-1.md"}'),l={name:"框架面试-wiki/11-升级Vue3.0/02-解答-1.md"},s=a('<h1 id="解答-1" tabindex="-1">解答-1 <a class="header-anchor" href="#解答-1" aria-label="Permalink to &quot;解答-1&quot;">​</a></h1><h2 id="vue3-0-比-vue2-x-的优势" tabindex="-1">Vue3.0 比 Vue2.x 的优势 <a class="header-anchor" href="#vue3-0-比-vue2-x-的优势" aria-label="Permalink to &quot;Vue3.0 比 Vue2.x 的优势&quot;">​</a></h2><ul><li>性能更好</li><li>体积更小</li><li>更好的 ts 支持</li><li>更好的代码组织</li><li>利于复杂逻辑抽离 - Composition API</li><li>增加了新功能 <code>Fragment</code> <code>Teleport</code> <code>Suspense</code></li></ul><p>虽然有很多更具体的数据，但不用可以去记录这些数据，跟我们日常开发也没有太多关系，了解即可。</p><p><img src="'+t+'" alt=""></p><h2 id="vue3-0-生命周期" tabindex="-1">Vue3.0 生命周期 <a class="header-anchor" href="#vue3-0-生命周期" aria-label="Permalink to &quot;Vue3.0 生命周期&quot;">​</a></h2><p>v2.x 的生命周期依然支持，需要注意的是：</p><ul><li>beforeDestroy 改名为 beforeUnmount</li><li>destroyed 改名为 unmounted</li></ul><p>新的 Composition API 有了新的生命周期。</p><p>看代码演示。</p><h2 id="你如何看待-composition-api-和-options-api" tabindex="-1">你如何看待 Composition API 和 Options API <a class="header-anchor" href="#你如何看待-composition-api-和-options-api" aria-label="Permalink to &quot;你如何看待 Composition API 和 Options API&quot;">​</a></h2><p>Composition API 是 vue3 的重要更新，也是使用者们最关注的部分。</p><ul><li>更好的代码组织</li><li>更好的逻辑复用 —— 这是两码事儿，后者依赖于前者</li><li>更好的类型推导</li></ul><h3 id="代码组织参考例子" tabindex="-1">代码组织参考例子 <a class="header-anchor" href="#代码组织参考例子" aria-label="Permalink to &quot;代码组织参考例子&quot;">​</a></h3><ul><li>实际的代码例子 <ul><li>v2 <a href="https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404" target="_blank" rel="noreferrer">https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404</a></li><li>v3 这里有 <a href="https://vue-composition-api-rfc.netlify.app/zh/#%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87" target="_blank" rel="noreferrer">https://vue-composition-api-rfc.netlify.app/zh/#代码组织</a></li></ul></li></ul><h3 id="关于-vue2-中的类型推导" tabindex="-1">关于 vue2 中的类型推导 <a class="header-anchor" href="#关于-vue2-中的类型推导" aria-label="Permalink to &quot;关于 vue2 中的类型推导&quot;">​</a></h3><ul><li>vue2 中的 this 的方式是比较微妙的。（比如 methods 选项下的函数的 this 是指向组件实例的，而不是这个 methods 对象）</li><li>vue2 设计时，是没有考虑 ts 的类型推导的</li></ul><h3 id="composition-api-和-options-api-如何选择" tabindex="-1">Composition API 和 Options API 如何选择？？ <a class="header-anchor" href="#composition-api-和-options-api-如何选择" aria-label="Permalink to &quot;Composition API 和 Options API 如何选择？？&quot;">​</a></h3><ul><li>不建议共用，会很混乱</li><li>普通情况下（之前用 vue2.x 也觉得挺好），建议还是继续用 Options API</li><li>如果系统复杂度比较高，则考虑使用 Composition API ，毕竟需要抽离很多逻辑</li></ul><h3 id="关于-composition-api-的误解-重要" tabindex="-1">关于 Composition API 的误解，重要！！！ <a class="header-anchor" href="#关于-composition-api-的误解-重要" aria-label="Permalink to &quot;关于 Composition API 的误解，重要！！！&quot;">​</a></h3><ul><li>从 vue3 的文档来看，Composition API 隐藏很深，在“高阶指南”里。如果从 0 学习 vue3 你是不太容易接触到它的，普通场景下你甚至都用不到它。它属于一个附加或者高级的额功能。所以，不要把它看的那么重要。</li><li>vue3 也支持 vue2 的 options API ，而且入门文档就是用的 Options API 。这其实就跟 React 的 class 组件和 Hooks 一样了。所以，Composition API 就像是 React Hooks ，是可选的，是为了解决特殊问题的，而不是必须的。</li></ul>',21),r=[s];function n(p,u,c,d,h,m){return o(),e("div",null,r)}const b=i(l,[["render",n]]);export{v as __pageData,b as default};
