import{_ as e,c as a,o as t,a1 as i}from"./chunks/framework.BwTyoF0R.js";const m=JSON.parse('{"title":"http 缓存","description":"","frontmatter":{},"headers":[],"relativePath":"基础面试-wiki/12-升级-http面试题/05-http缓存.md","filePath":"基础面试-wiki/12-升级-http面试题/05-http缓存.md"}'),l={name:"基础面试-wiki/12-升级-http面试题/05-http缓存.md"},o=i('<h1 id="http-缓存" tabindex="-1">http 缓存 <a class="header-anchor" href="#http-缓存" aria-label="Permalink to &quot;http 缓存&quot;">​</a></h1><h2 id="什么是缓存" tabindex="-1">什么是缓存 <a class="header-anchor" href="#什么是缓存" aria-label="Permalink to &quot;什么是缓存&quot;">​</a></h2><p>（画图，http 请求过程）</p><p>缓存，即某些情况下，资源不是每次都去服务端获取，而是第一次获取之后缓存下来。 下次再请求时，直接读取本地缓存，而不再去服务端请求。</p><h2 id="为什么需要缓存" tabindex="-1">为什么需要缓存 <a class="header-anchor" href="#为什么需要缓存" aria-label="Permalink to &quot;为什么需要缓存&quot;">​</a></h2><p>核心需求，让网页更快的显示出来，即提高性能。</p><ul><li>计算机执行计算，非常快</li><li>包括页面渲染，JS 执行等</li><li>加载资源却非常慢（相比于计算来说），而且受限于网络不可控。</li></ul><p>解决好最关键的问题 —— 缓存网络资源</p><h2 id="哪些资源需要缓存" tabindex="-1">哪些资源需要缓存 <a class="header-anchor" href="#哪些资源需要缓存" aria-label="Permalink to &quot;哪些资源需要缓存&quot;">​</a></h2><p>对于一个网页来说</p><ul><li>html 页面不能缓存</li><li>业务数据不能缓存（例如一个博客项目，里面的博客信息）</li><li>静态资源可以缓存，js css 图片等（所有的静态资源累加起来，体积是很大的）</li></ul><p>PS：讲 webpack 时讲过 <code>contentHash</code> ，就是给静态资源加上一个唯一的 hash 值，便于缓存。</p><h2 id="缓存策略-——-强制缓存-客户端缓存" tabindex="-1">缓存策略 —— 强制缓存，客户端缓存 <a class="header-anchor" href="#缓存策略-——-强制缓存-客户端缓存" aria-label="Permalink to &quot;缓存策略 —— 强制缓存，客户端缓存&quot;">​</a></h2><p><strong>Cache-Control</strong> (response headers 中) 表示该资源，被再次请求时的缓存情况。</p><ul><li><code>max-age:31536000</code> 单位是 s ，该资源被强制缓存 1 年</li><li><code>no-cache</code> 不使用强制缓存，但不妨碍使用协商缓存（下文会讲）</li><li><code>no-store</code> 禁用一起缓存，每次都从服务器获取最新的资源</li><li><code>private</code> 私有缓存（浏览器级缓存）</li><li><code>public</code> 共享缓存（代理级缓存）</li></ul><p>关于 Expires</p><ul><li>http 1.0 ，设置缓存过期时间的</li><li>由于本地时间和服务器时间可能不一致，会导致问题</li><li>已被 Cache-Control 的 max-age 代替</li></ul><h2 id="缓存策略-——-协商缓存-对比缓存-服务端缓存" tabindex="-1">缓存策略 —— 协商缓存（对比缓存），服务端缓存 <a class="header-anchor" href="#缓存策略-——-协商缓存-对比缓存-服务端缓存" aria-label="Permalink to &quot;缓存策略 —— 协商缓存（对比缓存），服务端缓存&quot;">​</a></h2><p>当强制缓存失效，请求会被发送到服务端。此时，服务端也不一定每次都要返回资源，如果客户端资源还有效的话。</p><p>第一，<strong>Last-Modified</strong>（Response Headers）和 <strong>If-Modified-Since</strong>（Request Headers）</p><ul><li>Last-Modified 服务端返回资源的最后修改时间</li><li>If-Modified-Since 再次请求时带着最后修改时间</li><li>服务器根据时间判断资源是否被修改（如未被修改则返回 304，失败则返回新资源和新的缓存规则）</li></ul><p>第二，<strong>Etag</strong>（Response Headers）和 <strong>If-None-Match</strong>（Request Headers）</p><ul><li>Etag 服务端返回的资源唯一标识（类似人的指纹，唯一，生成规则由服务器端决定，结果就是一个字符串）</li><li>If-None-Match 再次请求时带着这个标识</li><li>服务端根据资源和这个标识是否 match （成功则返回 304，失败则返回新资源和新的缓存规则）</li></ul><p>如果两者一起使用，则<strong>优先使用 Etag</strong> 规则。因为 Last-Modified 只能精确到秒级别。</p><h2 id="缓存策略-综述" tabindex="-1">缓存策略 - 综述 <a class="header-anchor" href="#缓存策略-综述" aria-label="Permalink to &quot;缓存策略 - 综述&quot;">​</a></h2><p>画图，参考视频</p><h2 id="刷新操作对应不同的缓存策略" tabindex="-1">刷新操作对应不同的缓存策略 <a class="header-anchor" href="#刷新操作对应不同的缓存策略" aria-label="Permalink to &quot;刷新操作对应不同的缓存策略&quot;">​</a></h2><p>三种操作</p><ul><li>正常操作：地址栏输入 url ，点击链接，前进后退等</li><li>手动刷新：F5 或者点击刷新按钮</li><li>强制刷新：ctrl + F5</li></ul><p>对应的缓存策略</p><ul><li>正常操作：强制缓存有效，协商缓存有效</li><li>手动刷新：强制缓存<em>失效</em>，协商缓存有效</li><li>强制刷新，强制缓存<em>失效</em>，协商缓存<em>失效</em></li></ul><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>关于 http 缓存的重点</p><ul><li>强缓存和协商缓存</li><li>几个 http headers</li><li>流程图</li></ul>',34),r=[o];function h(s,n,d,p,c,u){return t(),a("div",null,r)}const f=e(l,[["render",h]]);export{m as __pageData,f as default};
