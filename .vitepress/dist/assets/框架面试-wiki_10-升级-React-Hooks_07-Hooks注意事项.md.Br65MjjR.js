import{_ as e,c as t,o as a,a1 as o}from"./chunks/framework.BwTyoF0R.js";const p=JSON.parse('{"title":"React Hooks 的坑","description":"","frontmatter":{},"headers":[],"relativePath":"框架面试-wiki/10-升级-React-Hooks/07-Hooks注意事项.md","filePath":"框架面试-wiki/10-升级-React-Hooks/07-Hooks注意事项.md"}'),s={name:"框架面试-wiki/10-升级-React-Hooks/07-Hooks注意事项.md"},c=o('<h1 id="react-hooks-的坑" tabindex="-1">React Hooks 的坑 <a class="header-anchor" href="#react-hooks-的坑" aria-label="Permalink to &quot;React Hooks 的坑&quot;">​</a></h1><h2 id="usestate-的值-只有第一次有效" tabindex="-1">useState 的值，只有第一次有效 <a class="header-anchor" href="#usestate-的值-只有第一次有效" aria-label="Permalink to &quot;useState 的值，只有第一次有效&quot;">​</a></h2><p>useState 初始化值</p><ul><li>只在 render 时执行</li><li>re-render 时不会重新初始化</li><li>只能通过 setState 来修改</li></ul><p>参考 <code>UseStateTrap.js</code> 代码</p><h2 id="useeffect-内部不能修改-state" tabindex="-1">useEffect 内部不能修改 state <a class="header-anchor" href="#useeffect-内部不能修改-state" aria-label="Permalink to &quot;useEffect 内部不能修改 state&quot;">​</a></h2><p>useEffect 里面使用到的 state 的值, 固定在了 useEffect 内部， 不会被改变，除非 useEffect 刷新，重新固定state的值</p><p>参考 <code>UseEffectChangeState.js</code></p><h2 id="useeffect-死循环" tabindex="-1">useEffect 死循环 <a class="header-anchor" href="#useeffect-死循环" aria-label="Permalink to &quot;useEffect 死循环&quot;">​</a></h2><p>如果依赖项（即第二个参数）里有对象、数组，就会出现死循环。所以，依赖项里都要是值类型。 可以用 useAxios 进行演示，加一个 config 依赖项</p><p>因为 React Hooks 是通过 <code>Object.is</code> 进行依赖项的前后比较。 如果是值类型，则不妨碍。 如果是引用类型，前后的值是不一样的（纯函数，每次新建值），就类似 <code>{x:100} !== {x:100}</code></p>',11),r=[c];function i(f,d,n,l,u,_){return a(),t("div",null,r)}const k=e(s,[["render",i]]);export{p as __pageData,k as default};
