import{_ as s,c as i,o as a,a1 as e}from"./chunks/framework.BwTyoF0R.js";const g=JSON.parse('{"title":"Vue 错误监听","description":"","frontmatter":{},"headers":[],"relativePath":"面试刷题-wiki/05-实际工作经验/08-vue错误监听.md","filePath":"面试刷题-wiki/05-实际工作经验/08-vue错误监听.md"}'),n={name:"面试刷题-wiki/05-实际工作经验/08-vue错误监听.md"},t=e(`<h1 id="vue-错误监听" tabindex="-1">Vue 错误监听 <a class="header-anchor" href="#vue-错误监听" aria-label="Permalink to &quot;Vue 错误监听&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>如何统一监听 Vue 组件报错？</p><h2 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h2><p>真实项目需要<strong>闭环</strong>，即考虑各个方面，除了基本的功能外，还要考虑性能优化、报错、统计等。 而个人项目、课程项目一般以实现功能为主，不会考虑这么全面。所以，没有实际工作经验的同学，不会了解如此全面。</p><h2 id="window-onerror" tabindex="-1">window.onerror <a class="header-anchor" href="#window-onerror" aria-label="Permalink to &quot;window.onerror&quot;">​</a></h2><p>可以监听当前页面所有的 JS 报错，jQuery 时代经常用。<br> 注意，全局只绑定一次即可。不要放在多次渲染的组件中，这样容易绑定多次。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onerror</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">line</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">column</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;window.onerror---------&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, msg, source, line, column, error)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注意，如果用 window.addEventListener(&#39;error&#39;, event =&gt; {}) 参数不一样！！！</span></span></code></pre></div><h2 id="errorcaptured-生命周期" tabindex="-1">errorCaptured 生命周期 <a class="header-anchor" href="#errorcaptured-生命周期" aria-label="Permalink to &quot;errorCaptured 生命周期&quot;">​</a></h2><p>会监听所有<strong>下级组件</strong>的错误。可以返回 <code>false</code> 阻止向上传播，因为可能会有多个上级节点都监听错误。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">errorCaptured</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error, instance, info) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;errorCaptured--------&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, error, instance, info)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="errorhandler" tabindex="-1">errorHandler <a class="header-anchor" href="#errorhandler" aria-label="Permalink to &quot;errorHandler&quot;">​</a></h2><p>全局的错误监听，所有组件的报错都会汇总到这里来。PS：如果 <code>errorCaptured</code> 返回 <code>false</code> 则<strong>不会</strong>到这里。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> app</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createApp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(App)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.config.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">errorHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">instance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;errorHandler--------&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, error, instance, info)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>请注意，<code>errorHandler</code> 会阻止错误走向 <code>window.onerror</code>。</p><p>PS：还有 <code>warnHandler</code></p><h2 id="异步错误" tabindex="-1">异步错误 <a class="header-anchor" href="#异步错误" aria-label="Permalink to &quot;异步错误&quot;">​</a></h2><p>组件内的异步错误 <code>errorHandler</code> 监听不到，还是需要 <code>window.onerror</code></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;setTimeout 报错&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span></code></pre></div><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><p>方式</p><ul><li><code>errorCaptured</code> 监听下级组件的错误，可返回 <code>false</code> 阻止向上传播</li><li><code>errorHandler</code> 监听 Vue 全局错误</li><li><code>window.onerror</code> 监听其他的 JS 错误，如异步</li></ul><p>建议：结合使用</p><ul><li>一些重要的、复杂的、有运行风险的组件，可使用 <code>errorCaptured</code> 重点监听</li><li>然后用 <code>errorHandler</code> <code>window.onerror</code> 候补全局监听，避免意外情况</li></ul><h2 id="扩展" tabindex="-1">扩展 <a class="header-anchor" href="#扩展" aria-label="Permalink to &quot;扩展&quot;">​</a></h2><p>Promise 监听报错要使用 <code>window.onunhandledrejection</code> ，后面会有面试题讲解。</p><p>前端拿到错误监听之后，需要传递给服务端，进行错误收集和分析，然后修复 bug 。 后面会有一道面试题专门讲解。</p>`,27),r=[t];function h(l,p,k,d,o,E){return a(),i("div",null,r)}const u=s(n,[["render",h]]);export{g as __pageData,u as default};
