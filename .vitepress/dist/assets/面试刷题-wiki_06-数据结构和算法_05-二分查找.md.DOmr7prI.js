import{_ as a,c as e,o as t,a1 as r}from"./chunks/framework.BwTyoF0R.js";const b=JSON.parse('{"title":"二分查找","description":"","frontmatter":{},"headers":[],"relativePath":"面试刷题-wiki/06-数据结构和算法/05-二分查找.md","filePath":"面试刷题-wiki/06-数据结构和算法/05-二分查找.md"}'),i={name:"面试刷题-wiki/06-数据结构和算法/05-二分查找.md"},o=r('<h1 id="二分查找" tabindex="-1">二分查找 <a class="header-anchor" href="#二分查找" aria-label="Permalink to &quot;二分查找&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>用 Javascript 实现二分查找（针对有序数组），说明它的时间复杂度</p><h2 id="一个故事" tabindex="-1">一个故事 <a class="header-anchor" href="#一个故事" aria-label="Permalink to &quot;一个故事&quot;">​</a></h2><p>N 年前，百度，一个复杂的后台系统出现了问题，因为太大找不到问题所在。 一个工程师，使用二分法，很快找到了问题原因。</p><p>无论多么大的数据量，一旦有了二分，便可快速搞定。<br> 二分法，是算法的一个重要思维。</p><p>但二分法有一个条件：需要有序数据。</p><h2 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h2><p>二分查找是一种固定的算法，没什么可分析的。</p><p>两种实现思路</p><ul><li>递归 - 代码逻辑更加简洁</li><li>循环 - 性能更好（就调用一次函数，而递归需要调用很多次函数，创建函数作用域会消耗时间）</li></ul><p>时间复杂度 <code>O(logn)</code></p><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><p>参考 binary-search.ts 和 binary-search.test.ts</p><h2 id="划重点" tabindex="-1">划重点 <a class="header-anchor" href="#划重点" aria-label="Permalink to &quot;划重点&quot;">​</a></h2><ul><li>有序，就一定要想到二分</li><li>二分的时间复杂度必定包含 <code>O(logn)</code></li></ul>',16),l=[o];function n(s,c,h,d,_,p){return t(),e("div",null,l)}const m=a(i,[["render",n]]);export{b as __pageData,m as default};
