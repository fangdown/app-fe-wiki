import{_ as t,c as a,o as e,a1 as i}from"./chunks/framework.BwTyoF0R.js";const k=JSON.parse('{"title":"https","description":"","frontmatter":{},"headers":[],"relativePath":"基础面试-wiki/12-升级-http面试题/06-https.md","filePath":"基础面试-wiki/12-升级-http面试题/06-https.md"}'),p={name:"基础面试-wiki/12-升级-http面试题/06-https.md"},l=i('<h1 id="https" tabindex="-1">https <a class="header-anchor" href="#https" aria-label="Permalink to &quot;https&quot;">​</a></h1><p>http 是明文传输，传输的所有内容（如登录的用户名和密码），都会被中间的代理商（无论合法还是非法）获取到。</p><p>http + TLS/SSL = https ，即加密传输信息。只有客户端和服务端可以解密为明文，中间的过程无法解密。</p><h2 id="关于信息加密" tabindex="-1">关于信息加密 <a class="header-anchor" href="#关于信息加密" aria-label="Permalink to &quot;关于信息加密&quot;">​</a></h2><h3 id="对称加密" tabindex="-1">对称加密 <a class="header-anchor" href="#对称加密" aria-label="Permalink to &quot;对称加密&quot;">​</a></h3><p>一个密钥，既负责加密，又符合揭秘</p><ul><li>浏览器访问服务端，服务端生成密钥，并传递给浏览器</li><li>浏览器和服务端，通过这个密钥来加密、解密信息</li></ul><p>但这有一个很严重的问题：密钥也会被劫持</p><h3 id="非对称加密" tabindex="-1">非对称加密 <a class="header-anchor" href="#非对称加密" aria-label="Permalink to &quot;非对称加密&quot;">​</a></h3><p>生成一对密钥，一个公钥，一个私钥。</p><ul><li><p>公钥加密的信息，只有私钥能解密</p></li><li><p>私钥加密的信息，只有公钥能解密</p></li><li><p>浏览器访问服务端，服务端生成公钥、私钥，并把公钥传递给浏览器</p></li><li><p>浏览器生成一个 key（随机字符串），并用公钥加密，传递给服务端</p></li><li><p>服务端用私钥解密 key 。这样浏览器和服务端，就都得到了 key ，而且 key 还是加密传输的</p></li><li><p>然后，浏览器和服务端使用 key 为密钥，做对称加密传输</p></li></ul><p>思考：如果公钥和 key 被劫持，黑客能解密 key 吗？—— 不能，因为解密 key 要使用私钥，而私钥一只在服务端，没有传输。</p><h3 id="证书" tabindex="-1">证书 <a class="header-anchor" href="#证书" aria-label="Permalink to &quot;证书&quot;">​</a></h3><p>公钥劫持了不行，那替换行不行呢？<br> 黑客直接劫持请求，替换为自己的公钥（当然他自己有私钥），你的所有请求他劫持到，就都可以解密了。<br> 这叫做“中间人攻击”</p><p>这个问题，不好从技术上规避，那就从标准规范上解决 —— CA 证书。</p><ul><li>由正规的第三方结构，颁发证书（如去阿里云申请，但要花钱）</li><li>证书包括：公钥，域名，申请人信息，过期时间等 —— 这些都是绑定的</li><li>浏览器识别到正规的证书，才使用。否则会交给用户确认。</li></ul><p>这样，当黑客使用中间人攻击时，浏览器就会识别到它的证书不合规范，就会提示用户。</p><p>所以，尽量使用正规渠道申请的证书，花点钱，保证安全和稳定性。</p><h2 id="https-加密原理" tabindex="-1">https 加密原理 <a class="header-anchor" href="#https-加密原理" aria-label="Permalink to &quot;https 加密原理&quot;">​</a></h2><p>图示</p>',20),h=[l];function r(s,o,n,c,d,_){return e(),a("div",null,h)}const m=t(p,[["render",r]]);export{k as __pageData,m as default};
