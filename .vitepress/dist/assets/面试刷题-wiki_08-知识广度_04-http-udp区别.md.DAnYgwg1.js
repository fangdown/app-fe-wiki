import{_ as t,c as a,o as e,a1 as i}from"./chunks/framework.BwTyoF0R.js";const l="/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.B95Sn9sl.png",T=JSON.parse('{"title":"HTTP 和 UDP","description":"","frontmatter":{},"headers":[],"relativePath":"面试刷题-wiki/08-知识广度/04-http-udp区别.md","filePath":"面试刷题-wiki/08-知识广度/04-http-udp区别.md"}'),o={name:"面试刷题-wiki/08-知识广度/04-http-udp区别.md"},p=i('<h1 id="http-和-udp" tabindex="-1">HTTP 和 UDP <a class="header-anchor" href="#http-和-udp" aria-label="Permalink to &quot;HTTP 和 UDP&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>HTTP 和 UDP 有何区别</p><h2 id="网络协议" tabindex="-1">网络协议 <a class="header-anchor" href="#网络协议" aria-label="Permalink to &quot;网络协议&quot;">​</a></h2><p><img src="'+l+'" alt=""></p><ul><li>HTTP 在应用层，直接被程序使用</li><li>TCP 和 UDP 在传输层，底层</li></ul><h2 id="udp-的特点" tabindex="-1">UDP 的特点 <a class="header-anchor" href="#udp-的特点" aria-label="Permalink to &quot;UDP 的特点&quot;">​</a></h2><p>UDP 是一种无连接的、不可靠的传输层协议。而 TCP 需要连接、断开连接，参考“三次握手、四次挥手”。</p><p>不需要连接，所以 UDP 的效率比 TCP 高。</p><p>虽然 UDP 从协议层是不稳定的，但随着现代网络硬件环境的提升，也能保证绝大部分情况下的稳定性。所以，UDP 一直处于被发展的趋势。</p><p>例如视频会议、语音通话这些允许中段、不完全保证持续连接的场景，又需要较高的传输效率，就很适合 UDP 协议。</p><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><ul><li>HTTP 在应用层，而 UDP 和 TCP 在传输层</li><li>HTTP 是有连接的、可靠的，UDP 是无连接的、不可靠的</li></ul><h2 id="连环问-http-1-0-1-1-2-0-区别" tabindex="-1">连环问：http 1.0 1.1 2.0 区别 <a class="header-anchor" href="#连环问-http-1-0-1-1-2-0-区别" aria-label="Permalink to &quot;连环问：http 1.0 1.1 2.0 区别&quot;">​</a></h2><p>http 1.0 最基础的 http 协议</p><p>http 1.1</p><ul><li>引入更多的缓存策略，如 <code>cache-control</code> <code>E-tag</code></li><li>长链接，默认开启 <code>Connection: keep-alive</code> ，多次 http 请求减少了 TCP 连接次数</li><li>断点续传，状态吗 <code>206</code></li><li>增加新的 method <code>PUT</code> <code>DELETE</code> 等，可以设计 Restful API</li></ul><p>http2.0</p><ul><li>header 压缩，以减少体积</li><li>多路复用，一个 TCP 连接中可以多个 http 并行请求。拼接资源（如雪碧图、多 js 拼接一个）将变的多余</li><li>服务器端推送</li></ul>',19),h=[p];function d(r,c,n,s,P,u){return e(),a("div",null,h)}const D=t(o,[["render",d]]);export{T as __pageData,D as default};
