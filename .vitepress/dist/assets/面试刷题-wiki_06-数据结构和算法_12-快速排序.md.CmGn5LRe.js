import{_ as e,c as a,o as i,a1 as l}from"./chunks/framework.BwTyoF0R.js";const m=JSON.parse('{"title":"快速排序","description":"","frontmatter":{},"headers":[],"relativePath":"面试刷题-wiki/06-数据结构和算法/12-快速排序.md","filePath":"面试刷题-wiki/06-数据结构和算法/12-快速排序.md"}'),o={name:"面试刷题-wiki/06-数据结构和算法/12-快速排序.md"},c=l('<h1 id="快速排序" tabindex="-1">快速排序 <a class="header-anchor" href="#快速排序" aria-label="Permalink to &quot;快速排序&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>用 Javascript 实现快速排序，并说明时间复杂度。</p><h2 id="思路" tabindex="-1">思路 <a class="header-anchor" href="#思路" aria-label="Permalink to &quot;思路&quot;">​</a></h2><p>快速排序是基础算法之一，算法思路是固定的</p><ul><li>找到中间位置 midValue</li><li>遍历数组，小于 midValue 放在 left ，大于 midValue 放在 right</li><li>继续递归，concat 拼接</li></ul><h2 id="splice-和-slice" tabindex="-1">splice 和 slice <a class="header-anchor" href="#splice-和-slice" aria-label="Permalink to &quot;splice 和 slice&quot;">​</a></h2><p>代码实现时，获取 midValue 可以通过 <code>splice</code> 和 <code>slice</code> 两种方式</p><p>理论分析，<code>slice</code> 要优于 <code>splice</code> ，因为 <code>splice</code> 会修改原数组。<br> 但实际性能测试发现两者接近。</p><p>但是，即便如此还是倾向于选择 <code>slice</code> —— <strong>因为它不会改动原数组</strong>，类似于函数式编程</p><h2 id="性能分析" tabindex="-1">性能分析 <a class="header-anchor" href="#性能分析" aria-label="Permalink to &quot;性能分析&quot;">​</a></h2><p>快速排序 时间复杂度 <code>O(n*logn)</code> —— 有遍历，有二分</p><p>普通的排序算法（如冒泡排序）时间复杂度时 <code>O(n^2)</code></p><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><p>使用 slice 方案，参考 quick-sort.ts</p><h2 id="划重点" tabindex="-1">划重点 <a class="header-anchor" href="#划重点" aria-label="Permalink to &quot;划重点&quot;">​</a></h2><ul><li>排序算法（基本功）</li><li>二分法的时间复杂度</li><li>注意数组的操作（ <code>splice</code> vs <code>slice</code> ）</li></ul>',17),t=[c];function r(d,s,n,h,p,_){return i(),a("div",null,t)}const f=e(o,[["render",r]]);export{m as __pageData,f as default};
