import{_ as a}from"./chunks/时间复杂度.BHqu7MWC.js";import{_ as e,c as o,o as t,a1 as n}from"./chunks/framework.BwTyoF0R.js";const x=JSON.parse('{"title":"算法时间复杂度","description":"","frontmatter":{},"headers":[],"relativePath":"面试刷题-wiki/06-数据结构和算法/x2-文本小节-常见算法时间复杂度.md","filePath":"面试刷题-wiki/06-数据结构和算法/x2-文本小节-常见算法时间复杂度.md"}'),r={name:"面试刷题-wiki/06-数据结构和算法/x2-文本小节-常见算法时间复杂度.md"},i=n('<h1 id="算法时间复杂度" tabindex="-1">算法时间复杂度 <a class="header-anchor" href="#算法时间复杂度" aria-label="Permalink to &quot;算法时间复杂度&quot;">​</a></h1><p>本文总结一下前端算法常用的时间复杂度，对比学习。</p><p><img src="'+a+'" alt=""></p><h2 id="o-1" tabindex="-1">O(1) <a class="header-anchor" href="#o-1" aria-label="Permalink to &quot;O(1)&quot;">​</a></h2><p>代码就是平铺直叙的执行，没有任何循环。</p><h2 id="o-logn" tabindex="-1">O(logn) <a class="header-anchor" href="#o-logn" aria-label="Permalink to &quot;O(logn)&quot;">​</a></h2><p>有循环，但其中使用了二分法，例如：二分查找算法</p><p>二分法是非常重要的算法思维，它可以极大的减少复杂度，而且计算量越大、减少的越明显。可以看看本文上面的图。</p><h2 id="o-n" tabindex="-1">O(n) <a class="header-anchor" href="#o-n" aria-label="Permalink to &quot;O(n)&quot;">​</a></h2><p>普通的循环。</p><h2 id="o-n-logn" tabindex="-1">O(n*logn) <a class="header-anchor" href="#o-n-logn" aria-label="Permalink to &quot;O(n*logn)&quot;">​</a></h2><p>嵌套循环，一层是普通循环，一层有二分算法。例如：快速排序算法。</p><h2 id="o-n-2" tabindex="-1">O(n^2) <a class="header-anchor" href="#o-n-2" aria-label="Permalink to &quot;O(n^2)&quot;">​</a></h2><p>两个普通循环的嵌套，例如常见的冒泡排序。</p>',14),_=[i];function l(h,s,c,d,p,m){return t(),o("div",null,_)}const b=e(r,[["render",l]]);export{x as __pageData,b as default};
