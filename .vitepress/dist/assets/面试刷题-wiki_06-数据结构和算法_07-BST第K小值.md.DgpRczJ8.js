import{_ as a}from"./chunks/二叉搜索树.Cyrs3Gv9.js";import{_ as i,c as s,o as e,a1 as t}from"./chunks/framework.BwTyoF0R.js";const b=JSON.parse('{"title":"求二叉搜索树的第 K 小的值","description":"","frontmatter":{},"headers":[],"relativePath":"面试刷题-wiki/06-数据结构和算法/07-BST第K小值.md","filePath":"面试刷题-wiki/06-数据结构和算法/07-BST第K小值.md"}'),l={name:"面试刷题-wiki/06-数据结构和算法/07-BST第K小值.md"},h=t('<h1 id="求二叉搜索树的第-k-小的值" tabindex="-1">求二叉搜索树的第 K 小的值 <a class="header-anchor" href="#求二叉搜索树的第-k-小的值" aria-label="Permalink to &quot;求二叉搜索树的第 K 小的值&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>一个二叉搜索树，求其中的第 K 小的节点的值。 如下图，第 3 小的节点是 <code>4</code></p><p><img src="'+a+`" alt=""></p><h2 id="二叉树" tabindex="-1">二叉树 <a class="header-anchor" href="#二叉树" aria-label="Permalink to &quot;二叉树&quot;">​</a></h2><p>树，大家应该都知道，如前端常见的 DOM 树、vdom 结构。</p><p>二叉树，顾名思义，就是每个节点最多能有两个子节点。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ITreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 或其他类型</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ITreeNode</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ITreeNode</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="二叉树的遍历" tabindex="-1">二叉树的遍历 <a class="header-anchor" href="#二叉树的遍历" aria-label="Permalink to &quot;二叉树的遍历&quot;">​</a></h2><ul><li>前序遍历：root -&gt; left -&gt; right</li><li>中序遍历：left -&gt; root -&gt; right</li><li>后序遍历：left -&gt; right -&gt; root</li></ul><h2 id="二叉搜索树-bst" tabindex="-1">二叉搜索树 BST <a class="header-anchor" href="#二叉搜索树-bst" aria-label="Permalink to &quot;二叉搜索树 BST&quot;">​</a></h2><ul><li>左节点（包括其后代） &lt;= 根节点</li><li>右节点（包括其后代） &gt;= 根节点</li></ul><p>思考：BST 存在的意义是什么？—— 后面解释</p><h2 id="分析题目" tabindex="-1">分析题目 <a class="header-anchor" href="#分析题目" aria-label="Permalink to &quot;分析题目&quot;">​</a></h2><p>根据 BST 的特点，中序遍历的结果，正好是按照从小到大排序的结果。<br> 所以，中序遍历，求数组的 <code>arr[k]</code> 即可。</p><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><p>代码 binary-search-tree-k-value.ts</p><h2 id="划重点" tabindex="-1">划重点 <a class="header-anchor" href="#划重点" aria-label="Permalink to &quot;划重点&quot;">​</a></h2><ul><li>二叉搜索树的特点</li><li>前序、中序、后序遍历</li></ul>`,19),n=[h];function r(o,p,d,k,c,u){return e(),s("div",null,n)}const m=i(l,[["render",r]]);export{b as __pageData,m as default};
