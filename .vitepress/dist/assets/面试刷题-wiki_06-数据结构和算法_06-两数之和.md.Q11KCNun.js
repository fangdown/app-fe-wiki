import{_ as a,c as e,o as i,a1 as o}from"./chunks/framework.BwTyoF0R.js";const m=JSON.parse('{"title":"两数之和","description":"","frontmatter":{},"headers":[],"relativePath":"面试刷题-wiki/06-数据结构和算法/06-两数之和.md","filePath":"面试刷题-wiki/06-数据结构和算法/06-两数之和.md"}'),l={name:"面试刷题-wiki/06-数据结构和算法/06-两数之和.md"},t=o('<h1 id="两数之和" tabindex="-1">两数之和 <a class="header-anchor" href="#两数之和" aria-label="Permalink to &quot;两数之和&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>输入一个递增的数字数组，和一个数字 <code>n</code> 。求和等于 <code>n</code> 的两个数字。<br> 例如输入 <code>[1, 2, 4, 7, 11, 15]</code> 和 <code>15</code> ，返回两个数 <code>[4, 11]</code></p><h2 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h2><p>注意题目的要点</p><ul><li>递增，从小打大排序</li><li>只需要两个数字，而不是多个</li></ul><h2 id="常规思路" tabindex="-1">常规思路 <a class="header-anchor" href="#常规思路" aria-label="Permalink to &quot;常规思路&quot;">​</a></h2><p>嵌套循环，找个一个数，然后再遍历剩余的数，求和，判断。</p><p>时间复杂度 <code>O(n^2)</code> ，基本不可用。</p><h2 id="利用递增的特性" tabindex="-1">利用递增的特性 <a class="header-anchor" href="#利用递增的特性" aria-label="Permalink to &quot;利用递增的特性&quot;">​</a></h2><p>数组是递增的</p><ul><li>随便找两个数</li><li>如果和大于 n ，则需要向前寻找</li><li>如果和小于 n ，则需要向后寻找 —— <strong>二分法</strong></li></ul><p>双指针（指针就是索引，如数组的 index）</p><ul><li>i 指向头，j 指向尾， 求 i + j 的和</li><li>和如果大于 n ，则说明需要减少，则 j 向前移动（递增特性）</li><li>和如果小于 n ，则说明需要增加，则 i 向后移动（递增特性）</li></ul><p>时间复杂度降低到 <code>O(n)</code></p><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><p>方案二，参考 two-numbers-sum.ts</p><h2 id="划重点" tabindex="-1">划重点 <a class="header-anchor" href="#划重点" aria-label="Permalink to &quot;划重点&quot;">​</a></h2><ul><li>有序数据，要善用二分法</li><li>优化嵌套循环，可以考虑“双指针”</li></ul>',19),r=[t];function n(d,c,h,s,_,u){return i(),e("div",null,r)}const b=a(l,[["render",n]]);export{m as __pageData,b as default};
